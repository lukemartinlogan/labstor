#!/usr/bin/env python3

"""
USAGE: ./referesh_methods [TASK_NAME (snake case)]
"""

import yaml
import os
import sys
from codegen.util.paths import LABSTOR_ROOT

TASK_NAME = sys.argv[1]
TASK_ROOT = f'{LABSTOR_ROOT}/tasks/{TASK_NAME}'
METHODS_H = f'{TASK_ROOT}/include/{TASK_NAME}/{TASK_NAME}_methods.h'
METHODS_YAML = f'{TASK_ROOT}/include/{TASK_NAME}/{TASK_NAME}_methods.yaml'
LIB_EXEC_H = f'{TASK_ROOT}/include/{TASK_NAME}/{TASK_NAME}_lib_exec.h'
METHOD_MACRO = f'LABSTOR_{TASK_NAME.upper()}_METHODS_H_'
LIB_EXEC_MACRO = f'LABSTOR_{TASK_NAME.upper()}_LIB_EXEC_H_'

with open(METHODS_YAML) as fp:
    methods = yaml.load(fp, Loader=yaml.FullLoader)
methods = sorted(methods.items(), key=lambda x: x[1])
methods.insert(0, ('kConstruct', -2))
methods.insert(1, ('kDestruct', -1))

# Produce the TASK_NAME_methods.h file
lines = []
lines += [f'#ifndef {METHOD_MACRO}',
          f'#define {METHOD_MACRO}',
          '',
          'using labstor::TaskMethod;',
          'using labstor::BinaryOutputArchive;',
          'using labstor::BinaryInputArchive;',
          'using labstor::Task;',
          '',
          '/** The set of methods in the admin task */',
          'struct Method : public TaskMethod {']
for method_enum_name, method_off in methods:
    lines += f'  TASK_METHOD_T {method_enum_name} = kLast + {method_off};',
lines += ['};', '', f'#endif  // {METHOD_MACRO}']
with open(METHODS_H, 'w') as fp:
    fp.write('\n'.join(lines))


# Produce the TASK_NAME_lib_exec.h file
## Create the Run method
lines = []
lines += [f'#ifndef {LIB_EXEC_MACRO}',
          f'#define {LIB_EXEC_MACRO}',
          '']
lines += ['/** Execute a task */',
          'void Run(MultiQueue *queue, u32 method, Task *task) override {',
          '  switch (method) {']
for method_enum_name, method_off in methods:
    method_name = method_enum_name.replace('k', '')
    task_name = method_name + "Task"
    lines += [f'    case Method::{method_enum_name}: {{',
              f'      {method_name}(queue, reinterpret_cast<{task_name} *>(task));',
              f'      break;',
              f'    }}']
lines += ['  }']
lines += ['}']

## Create the SaveStart Method
lines += ['/** Serialize a task when initially pushing into remote */',
          'std::vector<DataTransfer> SaveStart(u32 method, BinaryOutputArchive<true> &ar, Task *task) override {',
          '  switch (method) {']
for method_enum_name, method_off in methods:
    method_name = method_enum_name.replace('k', '')
    task_name = method_name + "Task"
    lines += [f'    case Method::{method_enum_name}: {{',
              f'      ar << *reinterpret_cast<{task_name}*>(task);',
              f'      break;',
              f'    }}']
lines += ['  }']
lines += ['  return ar.Get();']
lines += ['}']

## Create the LoadStart Method
lines += ['/** Deserialize a task when popping from remote queue */',
          'TaskPointer LoadStart(u32 method, BinaryInputArchive<true> &ar) override {',
          '  TaskPointer task_ptr;',
          '  switch (method) {']
for method_enum_name, method_off in methods:
    method_name = method_enum_name.replace('k', '')
    task_name = method_name + "Task"
    lines += [f'    case Method::{method_enum_name}: {{',
              f'      task_ptr.task_ = LABSTOR_CLIENT->NewEmptyTask<{task_name}>(task_ptr.p_);',
              f'      ar >> *reinterpret_cast<{task_name}*>(task_ptr.task_);',
              f'      break;',
              f'    }}']
lines += ['  }']
lines += ['  return task_ptr;']
lines += ['}']

## Create the SaveEnd Method
lines += ['/** Serialize a task when returning from remote queue */',
          'std::vector<DataTransfer> SaveEnd(u32 method, BinaryOutputArchive<false> &ar, Task *task) override {',
          '  switch (method) {']
for method_enum_name, method_off in methods:
    method_name = method_enum_name.replace('k', '')
    task_name = method_name + "Task"
    lines += [f'    case Method::{method_enum_name}: {{',
              f'      ar << *reinterpret_cast<{task_name}*>(task);',
              f'      break;',
              f'    }}']
lines += ['  }']
lines += ['  return ar.Get();']
lines += ['}']

## Create the LoadEnd Method
lines += ['/** Deserialize a task when returning from remote queue */',
          'void LoadEnd(u32 method, BinaryInputArchive<false> &ar, Task *task) override {',
          '  switch (method) {']
for method_enum_name, method_off in methods:
    method_name = method_enum_name.replace('k', '')
    task_name = method_name + "Task"
    lines += [f'    case Method::{method_enum_name}: {{',
              f'      ar >> *reinterpret_cast<{task_name}*>(task);',
              f'      break;',
              f'    }}']
lines += ['  }']
lines += ['}']

## Finish the file
lines += ['', f'#endif  // {METHOD_MACRO}']

## Write TASK_NAME_lib_exec.h
with open(LIB_EXEC_H, 'w') as fp:
    fp.write('\n'.join(lines))
